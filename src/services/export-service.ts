// Export service - exports plans to various formats

import type {
  PlanWithPark,
  WeatherForecast,
  BandConditions,
  EquipmentPreset,
} from '../types/index.js';
import { getPresetById } from './equipment-presets.js';
import { format } from 'date-fns';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { dirname } from 'path';

export interface ExportOptions {
  format: 'markdown' | 'text' | 'json';
  outputPath: string;
  callsign?: string;
  gridSquare?: string;
}

/**
 * Export plan to specified format
 */
export function exportPlan(
  plan: PlanWithPark,
  options: ExportOptions
): { success: boolean; path: string; error?: string } {
  const { format: fmt, outputPath, callsign, gridSquare } = options;

  // Ensure output directory exists
  const dir = dirname(outputPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  let content: string;

  switch (fmt) {
    case 'markdown':
      content = formatMarkdown(plan, callsign, gridSquare);
      break;
    case 'text':
      content = formatText(plan, callsign, gridSquare);
      break;
    case 'json':
      content = formatJson(plan, callsign, gridSquare);
      break;
    default:
      return { success: false, path: outputPath, error: `Unknown format: ${fmt}` };
  }

  try {
    writeFileSync(outputPath, content, 'utf-8');
    return { success: true, path: outputPath };
  } catch (error) {
    return {
      success: false,
      path: outputPath,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Format plan as Markdown
 */
function formatMarkdown(
  plan: PlanWithPark,
  callsign?: string,
  gridSquare?: string
): string {
  const { park } = plan;
  const preset = plan.presetId ? getPresetById(plan.presetId as Parameters<typeof getPresetById>[0]) : null;
  const weather = parseWeather(plan.weatherCache);
  const bands = parseBands(plan.bandsCache);

  const dateStr = format(new Date(plan.plannedDate), 'EEEE, MMMM d, yyyy');

  let md = `# POTA Activation Plan\n\n`;

  // Park information
  md += `## Park Information\n`;
  md += `- **Reference:** ${park.reference}\n`;
  md += `- **Name:** ${park.name}\n`;
  md += `- **Location:** ${park.latitude.toFixed(4)}°N, ${Math.abs(park.longitude).toFixed(4)}°${park.longitude >= 0 ? 'E' : 'W'}\n`;
  if (park.gridSquare) {
    md += `- **Grid Square:** ${park.gridSquare}\n`;
  }
  if (park.state) {
    md += `- **State:** ${park.state}\n`;
  }
  md += `\n`;

  // Activation details
  md += `## Activation Details\n`;
  md += `- **Date:** ${dateStr}\n`;
  if (plan.plannedTime) {
    md += `- **Time:** ${plan.plannedTime}\n`;
  }
  if (plan.durationHours) {
    md += `- **Duration:** ${plan.durationHours} hours\n`;
  }
  md += `- **Status:** ${plan.status}\n`;
  md += `\n`;

  // Weather forecast
  if (weather) {
    md += `## Weather Forecast\n`;
    const forecast = weather.forecasts[0];
    if (forecast) {
      md += `| Metric | Value |\n`;
      md += `|--------|-------|\n`;
      md += `| High | ${forecast.highTemp}°F |\n`;
      md += `| Low | ${forecast.lowTemp}°F |\n`;
      md += `| Conditions | ${forecast.conditions} |\n`;
      md += `| Precipitation | ${forecast.precipitationChance}% chance |\n`;
      md += `| Wind | ${forecast.windSpeed} mph ${forecast.windDirection} |\n`;
      if (forecast.sunrise) md += `| Sunrise | ${forecast.sunrise} |\n`;
      if (forecast.sunset) md += `| Sunset | ${forecast.sunset} |\n`;
      if (weather.staleWarning) {
        md += `\n> ⚠️ ${weather.staleWarning}\n`;
      }
    }
    md += `\n`;
  }

  // Band recommendations
  if (bands && bands.recommendations.length > 0) {
    md += `## Band Recommendations\n`;
    md += `| Time | Band | Mode | Notes |\n`;
    md += `|------|------|------|-------|\n`;
    for (const rec of bands.recommendations) {
      md += `| ${rec.timeSlot} | ${rec.band} | ${rec.mode} | ${rec.notes} |\n`;
    }
    md += `\n> **Note:** ${bands.disclaimer}\n\n`;
  }

  // Equipment checklist
  if (preset) {
    md += `## Equipment Checklist\n`;
    md += `Using preset: **${preset.name}** (${preset.maxPower}W max)\n\n`;

    const itemsByType = groupItemsByType(preset.items);
    for (const [type, items] of Object.entries(itemsByType)) {
      md += `### ${capitalizeType(type)}\n`;
      for (const item of items) {
        md += `- [ ] ${item.name}`;
        if (item.description) md += ` (${item.description})`;
        if (item.quantity && item.quantity > 1) md += ` x${item.quantity}`;
        md += `\n`;
      }
      md += `\n`;
    }
  }

  // Notes
  if (plan.notes) {
    md += `## Notes\n`;
    md += `${plan.notes}\n\n`;
  }

  // Footer
  md += `---\n`;
  md += `*Generated by POTA Activation Planner on ${format(new Date(), 'yyyy-MM-dd')}*\n`;
  if (callsign) md += `*Callsign: ${callsign}`;
  if (gridSquare) md += ` | Grid: ${gridSquare}`;
  if (callsign || gridSquare) md += '*\n';

  return md;
}

/**
 * Format plan as plain text
 */
function formatText(
  plan: PlanWithPark,
  callsign?: string,
  gridSquare?: string
): string {
  const { park } = plan;
  const preset = plan.presetId ? getPresetById(plan.presetId as Parameters<typeof getPresetById>[0]) : null;
  const weather = parseWeather(plan.weatherCache);
  const bands = parseBands(plan.bandsCache);

  const dateStr = format(new Date(plan.plannedDate), 'EEEE, MMMM d, yyyy');

  let txt = ``;
  txt += `================================================================================\n`;
  txt += `                        POTA ACTIVATION PLAN\n`;
  txt += `================================================================================\n\n`;

  // Park information
  txt += `PARK: ${park.reference} - ${park.name}\n`;
  txt += `      ${park.latitude.toFixed(4)}°N, ${Math.abs(park.longitude).toFixed(4)}°${park.longitude >= 0 ? 'E' : 'W'}`;
  if (park.gridSquare) txt += ` (${park.gridSquare})`;
  txt += `\n`;
  if (park.state) txt += `      ${park.state}\n`;
  txt += `\n`;

  // Activation details
  txt += `DATE: ${dateStr}\n`;
  if (plan.plannedTime) txt += `TIME: ${plan.plannedTime}\n`;
  if (plan.durationHours) txt += `DURATION: ${plan.durationHours} hours\n`;
  txt += `STATUS: ${plan.status}\n\n`;

  // Weather forecast
  if (weather) {
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `WEATHER FORECAST\n`;
    txt += `--------------------------------------------------------------------------------\n`;
    const forecast = weather.forecasts[0];
    if (forecast) {
      txt += `High: ${forecast.highTemp}°F    Low: ${forecast.lowTemp}°F    Conditions: ${forecast.conditions}\n`;
      txt += `Precipitation: ${forecast.precipitationChance}% chance\n`;
      txt += `Wind: ${forecast.windSpeed} mph ${forecast.windDirection}\n`;
      if (forecast.sunrise && forecast.sunset) {
        txt += `Sunrise: ${forecast.sunrise}    Sunset: ${forecast.sunset}\n`;
      }
      if (weather.staleWarning) {
        txt += `\nWARNING: ${weather.staleWarning}\n`;
      }
    }
    txt += `\n`;
  }

  // Band recommendations
  if (bands && bands.recommendations.length > 0) {
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `BAND RECOMMENDATIONS\n`;
    txt += `--------------------------------------------------------------------------------\n`;
    for (const rec of bands.recommendations) {
      txt += `${rec.timeSlot.padEnd(15)}${rec.band.padEnd(8)}${rec.mode.padEnd(8)}${rec.notes}\n`;
    }
    txt += `\nNote: ${bands.disclaimer}\n\n`;
  }

  // Equipment checklist
  if (preset) {
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `EQUIPMENT CHECKLIST\n`;
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `Preset: ${preset.name} (${preset.maxPower}W max)\n\n`;
    for (const item of preset.items) {
      txt += `[ ] ${item.name}`;
      if (item.description) txt += ` - ${item.description}`;
      if (item.quantity && item.quantity > 1) txt += ` x${item.quantity}`;
      txt += `\n`;
    }
    txt += `\n`;
  }

  // Notes
  if (plan.notes) {
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `NOTES\n`;
    txt += `--------------------------------------------------------------------------------\n`;
    txt += `${plan.notes}\n\n`;
  }

  // Footer
  txt += `================================================================================\n`;
  txt += `Generated: ${format(new Date(), 'yyyy-MM-dd')}`;
  if (callsign) txt += ` | Callsign: ${callsign}`;
  if (gridSquare) txt += ` | Grid: ${gridSquare}`;
  txt += `\n================================================================================\n`;

  return txt;
}

/**
 * Format plan as JSON
 */
function formatJson(
  plan: PlanWithPark,
  callsign?: string,
  gridSquare?: string
): string {
  const { park } = plan;
  const preset = plan.presetId ? getPresetById(plan.presetId as Parameters<typeof getPresetById>[0]) : null;
  const weather = parseWeather(plan.weatherCache);
  const bands = parseBands(plan.bandsCache);

  const obj = {
    plan: {
      id: plan.id,
      createdAt: plan.createdAt,
      status: plan.status,
    },
    park: {
      reference: park.reference,
      name: park.name,
      latitude: park.latitude,
      longitude: park.longitude,
      gridSquare: park.gridSquare,
      state: park.state,
    },
    activation: {
      date: plan.plannedDate,
      time: plan.plannedTime,
      duration: plan.durationHours,
    },
    weather: weather?.forecasts[0] ?? null,
    bands: bands?.recommendations ?? [],
    equipment: preset
      ? {
          preset: preset.id,
          name: preset.name,
          items: preset.items,
        }
      : null,
    notes: plan.notes,
    operator: {
      callsign: callsign ?? null,
      gridSquare: gridSquare ?? null,
    },
  };

  return JSON.stringify(obj, null, 2);
}

// Helper functions
function parseWeather(cache: string | null): WeatherForecast | null {
  if (!cache) return null;
  try {
    return JSON.parse(cache) as WeatherForecast;
  } catch {
    return null;
  }
}

function parseBands(cache: string | null): BandConditions | null {
  if (!cache) return null;
  try {
    return JSON.parse(cache) as BandConditions;
  } catch {
    return null;
  }
}

function groupItemsByType(
  items: EquipmentPreset['items']
): Record<string, EquipmentPreset['items']> {
  const grouped: Record<string, EquipmentPreset['items']> = {};
  for (const item of items) {
    if (!grouped[item.type]) {
      grouped[item.type] = [];
    }
    grouped[item.type].push(item);
  }
  return grouped;
}

function capitalizeType(type: string): string {
  return type.charAt(0).toUpperCase() + type.slice(1);
}
